%! Author = matteomagnini
%! Date = 24/02/26

% Preamble
\documentclass[11pt]{article}

% Packages
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{my-acronyms}

\title{
    Intelligent System 2\\
    Tutorial week 2: First Order Logic
}

\date{
    27 February, 2026
}

% Document
\begin{document}

    \maketitle

    \section{More theory on First Order Logic}\label{sec:more-theory-on-first-order-logic}
    
    \subsection{Identity in First Order Logic}\label{subsec:identity-in-first-order-logic}

    We define the identity relation over a set $M$ as follows:
    \[
    \operatorname{Id}_M = \{(c, c) \in M \times M : c \in M\}
    \]
    In other words, $(x, y) \in \operatorname{Id}_M$ if and only if $x = y$.

    Let us introduce a symbol for identity $\approx_{(2)}$ in our language $\mathcal{L}$.
    In \ac{FOL}, it is customary to:
    \begin{itemize}
        \item write $\approx$ using infix notation $x \approx y$, rather than $\approx(x, y)$
        \item interpret $\approx$ as identity $=$, rather than as an arbitrary 2-ary relation over $M$
    \end{itemize}
    This way, with identity one cannot have any other interpretation, in contrast to other symbols; for example, $ken^{\mathcal{M}} = \text{Shrek}$ can have arbitrary interpretation.

    The semantics for $\approx$ are defined by:
    \[
    \mathcal{M} \models t_1 \approx t_2 \quad \text{iff} \quad t_1^{\mathcal{M}} = t_2^{\mathcal{M}}
    \]
    Technically, this means there is a subset of models that we do not use when checking logical consequence: we discard any model $\mathcal{M} = (M, \cdot^{\mathcal{M}})$ where $\approx^{\mathcal{M}}$ is not exactly $\operatorname{Id}_M$.

    Without $\approx$, we could express (1) but not (2):
    \begin{enumerate}
        \item everybody loves him/herself:\quad $\forall x\, Loves(x, x)$
        \item everybody loves him/herself at most:\quad $\forall x\, \forall y\, (Loves(x, y) \rightarrow x \approx y)$
    \end{enumerate}


    \subsection{Knowledge representation: Definite Descriptions}
    \label{subsec:knowledge-representation:-definite-descriptions}

    The way that \ac{FOL} handles the example ``A cat is on a mat'' is:
    \[
    \exists x\, \exists y\, (\text{Cat}(x) \wedge \text{Mat}(y) \wedge \text{Is\_On}(x, y))
    \]

    Consider now the natural language expression ``A pope is American'':
    \[
    \exists x\, (\text{Pope}(x) \wedge \text{American}(x))
    \]

    For definite descriptions, e.g.\ ``the Pope is American,'' the following form is proposed:
    \[
    \exists x\, (\text{Pope}(x) \wedge \forall y\, (\text{Pope}(y) \rightarrow x \approx y) \wedge \text{American}(x))
    \]

    One could more easily treat \textit{Pope} as a constant $pope \in \text{Ctt}$, of course, giving:
    \[
    \text{American}(pope)
    \]
    but this would have been problematic in centuries where there were two or more Popes simultaneously.

    In comparison, using the above formalization would give a false sentence in case of two popes, as expected.


    \subsection{Knowledge representation: Concepts}\label{subsec:knowledge-representation:-concepts}

    \paragraph{Example.}
    Consider the sentence:
    \begin{quote}
    A cat is on a box, and the box is on a mat.
    \end{quote}
    Based on the meaning of the natural language expressions ``is on'' and ``is above'', one can conclude that:
    \begin{quote}
    A cat is above a mat.
    \end{quote}

    Let us write a formal theory for this using two binary relations: $\text{Is\_On}_{(2)}$ and $\text{Is\_Above}_{(2)}$.

    \begin{enumerate}
        \item $\forall x\, \forall y\, (\text{Is\_On}(x, y) \rightarrow \text{Is\_Above}(x, y))$
        \item $\forall x\, \forall y\, \forall z\, ((\text{Is\_Above}(x, y) \wedge \text{Is\_Above}(y, z)) \rightarrow \text{Is\_Above}(x, z))$
    \end{enumerate}

    Note that (1) is a concept inclusion, and (2) states that ``being above'' is a transitive relation.


    \subsection{Knowledge Representation: Exercise}
    \label{subsec:knowledge-representation:-exercise}

    Let $\mathcal{L}$ be the language with $\mathsf{Pred} = \{\text{Child\_of}_{(2)},\, \text{Male}_{(1)},\, \text{Female}_{(1)}\}$.
    Expand $\mathcal{L}$ to include the predicates:

    \textit{Parent\_of(2), Father\_of(2), Mother\_of(2), Sibling\_of(2), Uncle\_of(2), Grandma\_of(2), Cousin\_of(2)}.

    Give a \ac{FOL} formula that defines each new predicate.

    \[
    \begin{array}{ll}
    \forall x\, \forall y\;(\text{Parent\_of}(x, y) \leftrightarrow \text{Child\_of}(y, x)) \\
    \forall x\, \forall y\;(\text{Father\_of}(x, y) \leftrightarrow \dots )\\
    \forall x\, \forall y\;(\text{Mother\_of}(x, y) \leftrightarrow \dots )\\
    \forall x\, \forall y\;(\text{Sibling\_of}(x, y) \leftrightarrow \dots )\\
    \forall x\, \forall y\;(\text{Uncle\_of}(x, y) \leftrightarrow \dots )\\
    \forall x\, \forall y\;(\text{Grandma\_of}(x, y) \leftrightarrow \dots )\\
    \forall x\, \forall y\;(\text{Cousin\_of}(x, y) \leftrightarrow \dots )\\
    \end{array}
    \]

    \textbf{Hint:} You can use predicates already defined when defining the theory for other predicates.

    \newpage
    \section{Exercises}\label{sec:exercises}

    \subsection{Exercise 1}\label{subsec:exercise-1}

    Let $\mathcal{L}_2$ be a first-order language with the following signature:
    \begin{itemize}
        \item $\text{Ctt} = \{a, b\}$
        \item $\text{Pred} = \{R^{(2)}\}$
        \item $\text{Func} = \{f^{(1)}\}$
    \end{itemize}

    Let a model $\mathcal{M} = (M, \cdot^\mathcal{M})$ be defined by:

    \begin{itemize}
        \item $M = \{\triangle,\, \square,\, \triangledown,\, \lozenge\}$
        \item $a^\mathcal{M} = \triangle$
        \item $b^\mathcal{M} = \square$
        \item $f^\mathcal{M}$ defined as:
            \[
                f^\mathcal{M} :
                \begin{cases}
                    \triangle \mapsto \square \\
                    \square \mapsto \triangledown \\
                    \triangledown \mapsto \lozenge \\
                    \lozenge \mapsto \triangle
                \end{cases}
            \]
        \item $R^\mathcal{M} = \{
            \langle \triangle,\, \triangledown \rangle,\;
            \langle \square,\, \lozenge \rangle,\;
            \langle \lozenge,\, \triangle \rangle,\;
            \langle \triangledown,\, \square \rangle
            \}$
    \end{itemize}

    Let $\mathcal{M}$ be an $\mathcal{L}_2$-structure and let $s$ be some assignment.

    \begin{enumerate}
        \item For each term, please give its interpretation with respect to $\mathcal{M}$:
        \begin{enumerate}
            \item $f(f(b))$
            \item $R(a, f(b))$
            \item $R(f(a), f(f(b)))$
        \end{enumerate}
        \item Are the following formulas satisfied in $\mathcal{M}$? Justify your answer briefly.
        \begin{enumerate}
            \item $R(a, f(b))$
            \item $R(f(f(f(a))), f(b))$
            \item $\forall x_1 \; (f(f(f(f(x_1)))) \approx x_1)$
        \end{enumerate}
    \end{enumerate}

    \subsection{Exercise 2}\label{subsec:exercise-2}

    Provide a model and a counter-model for the following formulas:

    \begin{enumerate}
        \item $\forall x\, ((P(x, b) \wedge Q(x)) \rightarrow R(x, a))$

        \item $\forall y\, (\exists x\ (R(a, x) \rightarrow (P(y, x) \wedge Q(y))))$
    \end{enumerate}


    \subsection{Exercise 3}\label{subsec:exercise-3}

    Translate the following first-order formulae into English, associating to each predicate the most intuitive meaning (e.g.\ \texttt{Human( )} is read as ``\, is a human''):

    \begin{enumerate}
        \item $\forall x\, (\text{Ostrich}(x) \rightarrow (\text{Bird}(x) \wedge \neg \text{Fly}(x) \wedge \text{Wings}(x)))$

        \item $\forall x\, \forall y\, ((\text{Wolf}(x) \wedge \text{Deer}(y)) \rightarrow \text{Hunts}(x, y))$

        \item $\forall x\, ((\text{Boat}(x) \wedge \text{Floats}(x, \text{Pacific})) \rightarrow (\neg\text{Leaky}(x) \wedge \exists y\, (\text{Crewed}(x, y))))$
    \end{enumerate}

\end{document}