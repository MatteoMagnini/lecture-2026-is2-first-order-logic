%! Author = matteomagnini
%! Date = 17/02/26

% Preamble
\documentclass[11pt]{article}

% Packages
\usepackage{amsmath}
\usepackage{amssymb}

\title{
    Intelligent System 2\\
    Tutorial week 2: First Order Logic
}

\date{
    27 February, 2026
}

% Document
\begin{document}

    \maketitle

    \section{Identity in First Order Logic}\label{sec:identity-in-first-order-logic}

    We define the identity relation over a set $M$ as follows:
    \[
    \operatorname{Id}_M = \{(c, c) \in M \times M : c \in M\}
    \]
    In other words, $(x, y) \in \operatorname{Id}_M$ if and only if $x = y$.

    Let us introduce a symbol for identity $\approx_{(2)}$ in our language $\mathcal{L}$.
    In First Order Logic (FOL), it is customary to:
    \begin{itemize}
        \item write $\approx$ using infix notation $x \approx y$, rather than $\approx(x, y)$
        \item interpret $\approx$ as identity $=$, rather than as an arbitrary 2-ary relation over $M$
    \end{itemize}
    This way, with identity one cannot have any other interpretation, in contrast to other symbols; for example, $ken^{\mathcal{M}} = \text{Shrek}$ can have arbitrary interpretation.

    The semantics for $\approx$ are defined by:
    \[
    \mathcal{M} \models t_1 \approx t_2 \quad \text{iff} \quad t_1^{\mathcal{M}} = t_2^{\mathcal{M}}
    \]
    Technically, this means there is a subset of models that we do not use when checking logical consequence: we discard any model $\mathcal{M} = (M, \cdot^{\mathcal{M}})$ where $\approx^{\mathcal{M}}$ is not exactly $\operatorname{Id}_M$.

    Without $\approx$, we could express (1) but not (2):
    \begin{enumerate}
        \item everybody loves him/herself:\quad $\forall x\, Loves(x, x)$
        \item everybody loves him/herself at most:\quad $\forall x\, \forall y\, (Loves(x, y) \rightarrow x \approx y)$
    \end{enumerate}


    \section{Knowledge representation: Definite Descriptions}
    \label{sec:knowledge-representation:-definite-descriptions}

    The way that FOL handles the example ``A cat is on a mat'' is:
    \[
    \exists x\, \exists y\, (\text{Cat}(x) \wedge \text{Mat}(y) \wedge \text{Is\_On}(x, y))
    \]

    Consider now the natural language expression ``A pope is American'':
    \[
    \exists x\, (\text{Pope}(x) \wedge \text{American}(x))
    \]

    For definite descriptions, e.g.\ ``the Pope is American,'' the following form is proposed:
    \[
    \exists x\, (\text{Pope}(x) \wedge \forall y\, (\text{Pope}(y) \rightarrow x \approx y) \wedge \text{American}(x))
    \]

    One could more easily treat \textit{Pope} as a constant $pope \in \text{Ctt}$, of course, giving:
    \[
    \text{American}(pope)
    \]
    but this would have been problematic in centuries where there were two or more Popes simultaneously.

    In comparison, using the above formalization would give a false sentence in case of two popes, as expected.


    \section{Knowledge representation: Concepts}\label{sec:knowledge-representation:-concepts}

    \paragraph{Example.}
    Consider the sentence:
    \begin{quote}
    A cat is on a box, and the box is on a mat.
    \end{quote}
    Based on the meaning of the natural language expressions ``is on'' and ``is above'', one can conclude that:
    \begin{quote}
    A cat is above a mat.
    \end{quote}

    Let us write a formal theory for this using two binary relations: $\text{Is\_On}_{(2)}$ and $\text{Is\_Above}_{(2)}$.

    \begin{enumerate}
        \item $\forall x\, \forall y\, (\text{Is\_On}(x, y) \rightarrow \text{Is\_Above}(x, y))$
        \item $\forall x\, \forall y\, \forall z\, ((\text{Is\_Above}(x, y) \wedge \text{Is\_Above}(y, z)) \rightarrow \text{Is\_Above}(x, z))$
    \end{enumerate}

    Note that (1) is a concept inclusion, and (2) states that ``being above'' is a transitive relation.


    \section{Knowledge Representation: Exercise}
    \label{sec:knowledge-representation:-exercise}

    Let $\mathcal{L}$ be the language with $\mathsf{Pred} = \{\text{Child\_of}_{(2)},\, \text{Male}_{(1)},\, \text{Female}_{(1)}\}$.
    Expand $\mathcal{L}$ to include the predicates:

    \textit{Parent\_of(2), Father\_of(2), Mother\_of(2), Sibling\_of(2), Uncle\_of(2), Grandma\_of(2), Cousin\_of(2)}.

    Give a FOL formula that defines each new predicate.

    \[
    \begin{array}{ll}
    \forall x\, \forall y\;(\text{Parent\_of}(x, y) \leftrightarrow \text{Child\_of}(y, x)) \\
    \forall x\, \forall y\;(\text{Father\_of}(x, y) \leftrightarrow \dots )\\
    \forall x\, \forall y\;(\text{Mother\_of}(x, y) \leftrightarrow \dots )\\
    \forall x\, \forall y\;(\text{Sibling\_of}(x, y) \leftrightarrow \dots )\\
    \forall x\, \forall y\;(\text{Uncle\_of}(x, y) \leftrightarrow \dots )\\
    \forall x\, \forall y\;(\text{Grandma\_of}(x, y) \leftrightarrow \dots )\\
    \forall x\, \forall y\;(\text{Cousin\_of}(x, y) \leftrightarrow \dots )\\
    \end{array}
    \]

    \textbf{Hint:} You can use predicates already defined when defining the theory for other predicates.

\end{document}